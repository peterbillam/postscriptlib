% motifs for use in Peter Billam's art, posters etc

% TODO: lavalamp_path  see Electrical Banana p.73
%       zigzag         ditto
%       x y height firtree    % trunkcolour and leafcolour are slightly random
%       peacock feather see Electrical Banana p.91  should use droplet_path
%       fronds  Electrical Banana p.111
%       colours Electrical Banana p.134
%       waves   Electrical Banana p.136
%       brain   for Road to Reality p.18   circular and seen from above


/irand     where { pop } { (/home/pjb/ps/lib/random.ps)  run } ifelse
/randomrgb where { pop } { (/home/pjb/ps/lib/colours.ps) run } ifelse

/reverse {   % usage: [ 5 4 3 2 1 (bang) ] reverse => [ (bang) 1 2 3 4 5 ]
  4 dict begin
  /a exch def
  /r a length array def
  /n a length 1 sub def
  0 1 n { /i exch def  r n i sub  a i get  put } for
  r
  end
} bind def

/rect { 4 dict begin   [ /h /w /y /x ] { exch def } forall
  x y moveto w 0 rlineto 0 h rlineto 0 w sub 0 rlineto x y lineto closepath
end } def

/circle { 3 dict begin  [ /r /y /x ] { exch def } forall
  x r add y moveto  x y r 0 360 arc  x r add y moveto closepath
  end
} def

/max {   % usage: a b max
    dup 3 2 roll dup 3 1 roll   % stack is now b a b a
    gt { pop } { exch pop } ifelse
} def
/min {   % usage: a b min
    dup 3 2 roll dup 3 1 roll lt { pop } { exch pop } ifelse
} def

/brain_outline_path {   % usage: x y height brain_outline_path
  % Gray's Anatomy p.644
  10 dict begin [ /height /y /x ] { exch def } forall
  x y translate  height 52 div dup scale
   0   49 moveto  % front
   0   51   1  52   3  52 curveto  % down the right hand side
   10  52  17  49  17  46 curveto
   24  48  39  20  33  18 curveto
   35  19  39  16  38  13 curveto  % now at the fissure of Rolando
   43  10  41 -7   39 -10 curveto
   42 -13  36 -34  29 -36 curveto
   30 -42  15 -52  6  -52 curveto
   1  -52   0 -49  0  -45 curveto  % now at rear
   0  -49  -1 -52 -6  -52 curveto  % back up the left hand side
  -15 -52 -30 -42 -29 -36 curveto
  -36 -34 -42 -13 -39 -10 curveto
  -41  -7 -43  10 -38  13 curveto
  -39  16 -35  19 -33  18 curveto
  -39  20 -24  48 -17  46 curveto
  -17  49 -10  52 -5   52 curveto
  -1   52   0  51  0   49 curveto  % front again
  closepath
  52 height div  dup  scale  0 x sub  0 y sub  translate
  end
} def

/brain_folds_path {   % usage: x y height brain_folds_path
  10 dict begin [ /height /y /x ] { exch def } forall
  x y translate  height 52 div dup scale
   0  49 moveto  % front
   0  43 lineto 0  41 -1  39 -2 39 curveto -1 39 0 38 0 36 curveto
   0  34 lineto 0  30 -1  28 -1.5 28 curveto -1 28 1 27 1.5 27 curveto
   1 27 0 26 0  24 curveto
   0  18 lineto 0  16 -1  14 -2 14 curveto -1 14 0 13 0 11 curveto
   0   8 lineto 0   6 -1   4 -2  4 curveto -1  4 0  3 0  1 curveto
   0  -8 lineto 0 -12 -1 -14 -1.5 -14 curveto -1 -14 1 -15 1.5 -15 curveto
   % from here will go the calloso-marginal fissure ...
   1 -15 0 -16 0  -18 curveto
   0 -20 lineto 0 -22  1 -24  2 -24 curveto  1 -24 0 -25 0 -27 curveto
                0 -27 -1 -29 -2 -29 curveto -1 -29 0 -30 0 -32 curveto
                0 -34  1 -36  1.5 -36 curveto  1 -36 -1 -37 -1.5 -37 curveto
     -1 -37 0 -38 0  -40 curveto
                0 -40  1 -42  2 -42 curveto  1 -42 0 -43 0 -45 curveto
   % rear
   38 13 moveto  36 10 32 8 29 8 curveto 26 5 24 4 21 4 curveto
    18 4 16 0 13 0 curveto 10 0 7 -4 4 -4 curveto % R fissure of Rolando
   -38 13 moveto  -36 10 -32 8 -29 8 curveto -26 5 -24 4 -21 4 curveto
    -18 4 -16 0 -13 0 curveto -10 0 -7 -4 -4 -4 curveto % L fissure of Rolando
  -1.5 -14 moveto -3.5 -14 -4 -13 -6 -13 curveto
   1.5 -15 moveto 6 -14 9 -10 13 -10 curveto % the calloso-marginal fissure
   2 -24 moveto 6 -23 10 -22 13 -20 curveto
  -2 -29 moveto -4 -29 -5 -28 -7 -28 curveto
   1.5 -36 moveto  5 -36 8 -36 9 -33 curveto
  -1.5 -37 moveto  -5 -37 -7 -37 -10 -39 curveto
   2  -42 moveto  5 -42 lineto
   29 -36 moveto  26 -36  24 -37  21 -40 curveto  % R parieto-occipital fissure
  -29 -36 moveto -26 -36 -24 -37 -21 -40 curveto  % L parieto-occipital fissure
   17  46 moveto 18 44 16 43 14 43 curveto 19 43 14 19 19 16 curveto
     19 14 15 8 12 6 curveto
     19 16 moveto 23 16 25 14 28 16 curveto % R sup frontal sulcus
   -6 49 moveto -15 40 lineto -18 15 lineto -15 8 lineto -8 7 lineto
   -18 15 moveto -28 17 lineto
   -15 8 moveto -19 6 lineto
  39  -10 moveto  34 -13 lineto
  -39 -10 moveto -34 -13 lineto
  38 9 moveto 33 4 26 -15 22 -12 curveto % the sulcus in the R parietal ..
  25 -15 21 -27 18 -26 curveto   20 -28 17 -30 14 -34 curveto
  22 -12 moveto 19 -10 lineto
  -38 9 moveto -33 4 -26 -15 -22 -12 curveto % mirrored in the L parietal ..
  -25 -15 -21 -27 -18 -26 curveto   -20 -28 -17 -30 -14 -34 curveto
  -22 -12 moveto -19 -10 lineto
  52 height div  dup  scale  0 x sub  0 y sub  translate
  end
} def

% https://en.wikipedia.org/wiki/Lobes_of_the_brain
% https://en.wikipedia.org/wiki/Occipital_lobe   visual processing
% https://en.wikipedia.org/wiki/Parietal_lobe    other senses, language
% https://en.wikipedia.org/wiki/Frontal_lobe     attention, short-term memory

/brain_show {   % usage: x y height  fillcolor strokecolor  brain_show
  % A convenient wrapper for the above brain_ procedures.
  % It might be nice to allow transparency ,
  %  which could be done by detecting a magic 'transparent' colour ...
  10 dict begin
    /strokecolor 4 1 roll rgbdef  /fillcolor 4 1 roll rgbdef
    [ /height /y /x ] { exch def } forall
  fillcolor setrgbcolor
    x y height brain_outline_path fill
  strokecolor setrgbcolor
    height .01 mul setlinewidth  x y height brain_outline_path stroke
    x y height brain_folds_path stroke
  end
} def

/droplet_path {  % usage: x0 y0  x1 y1  angle1  droplet_path
  15 dict begin
  [ /angle1 /y1 /x1 /y0 /x0 ] { exch def } forall
  x0 x1 eq y0 y1 eq and { % 20170603  defend atan against x0==x1 and y0=y1
    x0 y0 moveto x1 y1 lineto closepath % create a zero-size path at x0,y0
  } {
    /len  x1 x0 sub dup mul  y1 y0 sub dup mul  add  sqrt def
    /rot x1 x0 sub  y1 y0 sub  atan  -1 mul def
    /pw 0.17 def  /nw 0.0 pw sub def  % positive and negative halfwidths
    /ro .60 def    % roundness at base
    /sinang angle1 1.5 mul sin def
    /dx_hip   .06  sinang mul def
    /dy_hip   .30  sinang mul def
    /hip_tilt .025 sinang mul def
    x0 y0 translate  len dup scale  rot rotate
    0 0 moveto     % bottom
    pw ro mul                       0
      pw dx_hip add hip_tilt sub   pw 1.4 dy_hip add mul 1.0 ro sub mul
      pw dx_hip add                 pw 1.4 dy_hip add mul curveto   % right hip
    pw   dx_hip add hip_tilt add   .4
     .03 0.3 sinang mul add         .7
      0 1 curveto  % top
    -.03 0.3 sinang mul add         .7
      nw dx_hip add hip_tilt add   .4
      nw dx_hip add                 pw 1.4 dy_hip sub mul curveto  % left hip
    nw   dx_hip add hip_tilt sub   pw 1.4 dy_hip sub mul 1.0 ro sub mul
      nw ro mul                     0
      0 0 curveto  % bottom
    closepath
    0.0 rot sub rotate  1.0 len div dup scale  0 x0 sub 0 y0 sub translate
  } ifelse
  end
} bind def   % 20160704

/peacock_feather {   % x1 y1 x2 y2 angle colour1 colour2 colour3 
  10 dict begin
  [ /colour3 /colour2 /colour1 ] { 4 1 roll rgbdef } forall
  [ /angle /y2 /x2 /y1 /x1 ] { exch def } forall
  colour1 setrgbcolor
  newpath x1 y1 x2 y2 angle droplet_path fill
  colour2 setrgbcolor newpath
    x1 y2 y1 sub .02 mul angle sin mul sub           y1 .95 mul y2 .05 mul add
    x2 y2 y1 sub 0.2 mul angle sin mul 1.6 mul add   y1 .35 mul y2 .65 mul add
  angle 0.5 mul  droplet_path fill
  colour3 setrgbcolor newpath
    x1 y2 y1 sub .01 mul angle sin mul sub           y1 .90 mul y2 .10 mul add
    x2 y2 y1 sub 0.21 mul angle sin mul 2.0 mul add  y1 .60 mul y2 .40 mul add
  angle 0.3 mul  droplet_path gsave clip fill
  newpath colour1 setrgbcolor
    x1 y2 y1 sub .05 mul angle sin mul add           y1 .80 mul y2 .20 mul add
    x2 y2 y1 sub .35 mul angle sin mul add           y1 .40 mul y2 .60 mul add
    angle 0.3 mul  droplet_path fill
  grestore
  end
} def   % 20160706

/star_path {  % x y radius star_path
  10 dict begin
  [ /radius /y /x ] { exch def } forall
  x y translate  radius dup  scale  % x == y ==
  /r_out 1.40 def  /r_in 1.0 r_out div def
  /n 3000 irand def
  n 2000 ge {      % 5 points
    /rot 72 irand def rot rotate
   	r_in 0 moveto  r_out 36 cos mul r_out 36 sin mul lineto
   	r_in   72 cos mul r_in   72 sin mul lineto
    r_out 108 cos mul r_out 108 sin mul lineto
   	r_in  144 cos mul r_in  144 sin mul lineto
    r_out 180 cos mul r_out 180 sin mul lineto
   	r_in  216 cos mul r_in  216 sin mul lineto
    r_out 252 cos mul r_out 252 sin mul lineto
   	r_in  288 cos mul r_in  288 sin mul lineto
    r_out 324 cos mul r_out 324 sin mul lineto
    0 rot sub rotate
  } {
    n 1000 ge {  % 6 points
      /rot 60 irand def rot rotate
      r_in 0 moveto  r_out 30 cos mul r_out 30 sin mul lineto
      r_in   60 cos mul r_in   60 sin mul lineto
      r_out  90 cos mul r_out  90 sin mul lineto
      r_in  120 cos mul r_in  120 sin mul lineto
      r_out 150 cos mul r_out 150 sin mul lineto
      r_in  180 cos mul r_in  180 sin mul lineto
      r_out 210 cos mul r_out 210 sin mul lineto
      r_in  240 cos mul r_in  240 sin mul lineto
      r_out 270 cos mul r_out 270 sin mul lineto
      r_in  300 cos mul r_in  300 sin mul lineto
      r_out 330 cos mul r_out 330 sin mul lineto
      0 rot sub rotate
    } {            % 7 points
      /rot 51 irand def rot rotate
      r_in 0 moveto  r_out 26 cos mul r_out 26 sin mul lineto
      r_in   51 cos mul r_in   51 sin mul lineto
      r_out  77 cos mul r_out  77 sin mul lineto
      r_in  103 cos mul r_in  103 sin mul lineto
      r_out 129 cos mul r_out 129 sin mul lineto
      r_in  154 cos mul r_in  154 sin mul lineto
      r_out 180 cos mul r_out 180 sin mul lineto
      r_in  206 cos mul r_in  206 sin mul lineto
      r_out 231 cos mul r_out 231 sin mul lineto
      r_in  257 cos mul r_in  257 sin mul lineto
      r_out 283 cos mul r_out 283 sin mul lineto
      r_in  309 cos mul r_in  309 sin mul lineto
      r_out 334 cos mul r_out 334 sin mul lineto
      0 rot sub rotate
    } ifelse
  } ifelse
  closepath
  1.0 radius div dup scale  0 x sub  0 y sub  translate
  end
} bind def

/pjb::tree:depth 0 def
/bare_tree {   % x y height trunkfraction bare_tree
  % deciduous in winter, eg for silhouette against the sky
  newpath  % stroke because of changing linewidth; I could build rectangles,
  % but now we're stroking, I can use gsave grestore to get into the branches..
  % else I have to build up fractal arrays of arrays of the branch-points.
  % trunkfraction is the fraction of sap-flow that goes into the two branches.
  /pjb::tree:depth pjb::tree:depth 1 add def
  10 dict begin
  [/trunkfraction /height /y /x] {exch def} forall
  trunkfraction 0.01 lt { /trunkfraction 0.01 def } if
  trunkfraction 0.99 gt { /trunkfraction 0.99 def } if
  /branchwidth trunkfraction sqrt def
  gsave
  x y translate  height dup scale
  /trunkwidth 0.07 def   % width at ground level;  parameter ?
  % S(n) = 1 = a * (1-r^n) / (1-r)  ==>  a = (1-r) / (1-r^n)  =~ 1-r
  % r should be nearly 1 if branchwidth is small, so try r=1-branchwidth
  /a 1 branchwidth sub def  % a and r are constant, whereas
  /r branchwidth def        % trunkwidth and branchwidth shrink.
  trunkwidth setlinewidth
  0 0 moveto
  0 1 10 { /i exch def
    1.0 trunkwidth sub  i exp  0.010 lt { exit } if  % finished ?
    a r i exp mul  dup 0 0.15 grand mul  exch  rlineto
    currentpoint stroke moveto % separate strokes for separate linewidths!
    pjb::tree:depth 3 lt {
      gsave
      currentpoint translate  60 10 grand rotate 
      0 0 r i 0.5 mul 2 add exp trunkfraction bare_tree
      grestore
      gsave
      currentpoint translate -60 10 grand rotate 
      0 0 r i 0.5 mul 2 add exp trunkfraction bare_tree
      grestore
    } if
    /trunkwidth trunkwidth r mul def
    trunkwidth setlinewidth
  } for
  grestore
  end
  /pjb::tree:depth pjb::tree:depth 1 sub def
} bind def
% 297 100 442 0.5 bare_tree

/leopardskin_path {   % x y xwidth yheight spacing leopardskin_path
  % on an approximately triangular grid, with position and size
  % randomised with gauss_rand, and probably also a random choice of
  % daisy-flower-spot-shapes (with irand cvx exec, see musical_signs.ps)
  /leopardskin_dx exch def  /leopardskin_h exch def /leopardskin_w  exch def
  /leopardskin_y0 exch def  /leopardskin_x0 exch def
} bind def

/polkadots_path {     % x y xwidth yheight spacing dotsize polkadots_path
  % on a diagonal grid ? or a triangular grid ?
} bind def

/stripes_path {     % x y xwidth yheight spacing angle ratio stripes_path
  % see examples/nuits_sonores_2016.jpg
  % stripes are spacing*ratio wide ; so 0.5 gives equal strip and space
} bind def

/fish_path { % x y size fish_path
  % or: x y size fgcolour bgcolour fish  ?  to do the bg and the scales...
  /fish_size exch def  /fish_y exch def  /fish_x exch def
  fish_x  fish_y  translate  fish_size dup scale
  -0.5 0 moveto  -0.3 0.22  0.3 0.22  0.5 0 curveto
  0.3 -0.22 -0.3 -0.22 -0.5 0  curveto closepath
  1.0 fish_size div dup scale  0 fish_x sub  0 fish_y sub  translate
} bind def

%/blob {  % a random-blob-of-spilled-ink generator
% irand 5,6 or 7 excresences, x,ys grand'ed from points on a circle,
% angles rand
%}

/footprint_path {  % x y size rightleft angle footprint_path
  % if rightleft is false it's a left foot;
  /footprint_angle exch def
  /footprint_rightleft     exch def /footprint_size exch def
  /footprint_y     exch def /footprint_x    exch def
  footprint_x footprint_y translate
  footprint_angle rotate
  footprint_size dup  footprint_rightleft not { -1.0 mul } if  scale
  % the toes:
  1.5 1.0 scale
  .273 .21  moveto .273  .16 .05  90 450 arc closepath
  .263 .065 moveto .263  .03 .035 90 450 arc closepath
  .25 -.03  moveto .25  -.06 .03  90 450 arc closepath
  .23 -.105 moveto .23  -.13 .025 90 450 arc closepath
  .20 -.175 moveto .20  -.20 .025 90 450 arc closepath
  1.0 1.5 div 1.0 scale
  % the sole
   .31  .00 moveto
   .31  .15   .29  .18   .20  .18  curveto  % to ball
   .10  .18   .07  .00  -.10  .00  curveto  % to instep
  -.25  .00  -.28  .08  -.35  .08  curveto
  -.45  .08  -.48  .04  -.48  .00  curveto  % to heel
  -.48 -.10  -.40 -.16  -.30 -.16  curveto
  -.20 -.16  -.20 -.14  -.08 -.14  curveto
   .05 -.14   .12 -.20   .19 -.20  curveto
   .25 -.20   .31 -.10   .31  .00  curveto
  closepath
  1.0 footprint_size div dup  footprint_rightleft not { -1.0 mul } if  scale
  0.0 footprint_angle sub rotate
  0.0 footprint_x sub 0.0 footprint_y sub translate
} bind def

% but how to generate that random non-intersecting-squiggles-pattern,
%   where the bends and especially end-points are bulbous ?
% and what about some more poygonically-exotic tilings than chessboard_path ?

% for a different shape see also:   ~/ps/sine_curve_of_beauty.ps
/curve_of_beauty_path {  % usage: x0 y0 angle0 x1 y1 angle1
  % -ve angles mean an  S-shape  (go left, veer right, veer left)
  % +ve angles mean an inverse-S (go right, veer left, veer right)
  /beauty_a3 exch def /beauty_y3 exch def /beauty_x3 exch def
  /beauty_a0 exch def /beauty_y0 exch def /beauty_x0 exch def
  % calculate x1_out y1_out x2_out y2_out, x2_back y2_back x1_back y1_back
  beauty_x0  beauty_y0  translate
  /beauty_len beauty_x3 beauty_x0 sub dup mul  beauty_y3 beauty_y0 sub dup mul
    add sqrt def
  beauty_len  dup  scale
  % and when  x0 == x3  ??
  /beauty_rotate  beauty_y3 beauty_y0 sub  beauty_x3 beauty_x0 sub  atan  def
  beauty_rotate rotate
  newpath
    % to avoid x-over, the INSIDE y has to be smaller, the OUTSIDE larger
	% but abs supresses knowledge of which is which...
    0 0 moveto  % x0, y0
    beauty_a0 10 add cos beauty_a0 10 add 0.003 mul abs 0.4 add  mul % x1
    beauty_a0 10 add sin beauty_a0 10 add 0.003 mul abs 0.4 add  mul % y1
    1.0 beauty_a3 10 sub cos beauty_a3 10 sub 0.003 mul abs 0.4 add mul sub
    beauty_a3 10 sub sin beauty_a3 10 sub 0.003 mul abs -1.0 mul -0.4 add mul 
	1.0 0.0  curveto  % x3, y3
    1.0 beauty_a3 10 add cos beauty_a3 10 add 0.003 mul abs 0.4 add mul sub
    beauty_a3 10 add sin beauty_a3 10 add 0.003 mul abs -1.0 mul -0.4 add mul
    beauty_a0 10 sub cos beauty_a0 10 sub 0.003 mul abs 0.4 add  mul
    beauty_a0 10 sub sin beauty_a0 10 sub 0.003 mul abs 0.4 add  mul
    0.0 0.0  curveto
  closepath
  beauty_rotate -1.0 mul rotate
  1.0 beauty_len div  dup  scale
  beauty_x0 -1.0 mul  beauty_y0 -1.0 mul  translate
} bind def

/moon_path {  % usage:  x y radius solar_angle phase moon_path
  % solar_angle night means <0, =-90 or =90 means tropics
  % phase 0.0=new 0.5=full 1.0=old
  /moon::phase exch def /moon::sun_angle exch 180 add def
  /moon::r exch def /moon::y exch def /moon::x exch def
  % [ moon::x moon::y moon::r ] ==
  moon::x moon::y translate  moon::sun_angle rotate
  % better than 180 rotate, should change the angles for the arcs...
  moon::phase 0.5 ge { /moon::phase 1.0 moon::phase sub def } if
  /moon::scale 1.0 moon::phase 3.99 mul sub def  % could use sin ?
  newpath
    0 0 moon::r  90 270 arc
    moon::scale         1.0 scale
    0 0 moon::r -90 90 arcn
    1.0 moon::scale div 1.0 scale
  closepath
  moon::sun_angle -1.0 mul rotate
  moon::x -1.0 mul moon::y -1.0 mul translate
} bind def

/vedra_path {   % usage:  x_left y_left  width  vedra_path
  /vedra_width exch def /vedra_y1 exch def /vedra_x1 exch def
  newpath   % /home/pjb/photos/2008/dsc00156.jpg
  vedra_x1 vedra_y1 translate
  vedra_width 1293 div dup scale
     0    0 moveto   19   34 lineto   28   35 lineto
    56  107 lineto   85  107 lineto
    99   88 lineto  105   72 lineto  114   71 lineto  117   65 lineto
   125   64 lineto  125   68 lineto  130   68 lineto  131   64 lineto
   136   63 lineto  136   69 lineto  139   75 lineto  151   73 lineto
   154   61 lineto  160   59 lineto  162   54 lineto  170   58 lineto
   174   56 lineto  178   61 lineto  191   63 lineto  196   59 lineto
   222   78 lineto  222   89 lineto  240  101 lineto  249   95 lineto
   261  103 lineto  301   93 lineto  310   94 lineto  315   93 lineto
   319   94 lineto  329   94 lineto  338   89 lineto  352   88 lineto
   356   86 lineto  361   86 lineto  361   89 lineto  373   91 lineto
   376   88 lineto  381   91 lineto  397   91 lineto  403   97 lineto
   406   98 lineto  408  103 lineto  414  102 lineto  426  106 lineto
   435  105 lineto  436  114 lineto  443  117 lineto  453  115 lineto
   460  122 lineto  461  127 lineto  470  129 lineto  480  140 lineto
   499  146 lineto  510  145 lineto  513  148 lineto  517  145 lineto
   526  147 lineto  531  166 lineto  533  166 lineto  534  193 lineto
   548  202 lineto  582  212 lineto  587  217 lineto  598  218 lineto
   607  215 lineto  616  200 lineto  622  198 lineto  624  201 lineto
   632  204 lineto  634  211 lineto  647  217 lineto  663  202 lineto
   662  185 lineto  664  180 lineto  663  170 lineto  671  153 lineto
   674  133 lineto  681  126 lineto  691  120 lineto  695  111 lineto
   698   99 lineto  709   91 lineto  714   69 lineto  724   60 lineto
   738   53 lineto  742   55 lineto  749   52 lineto  752   41 lineto
   758   40 lineto  758   30 lineto  768   28 lineto  768   18 lineto
   789    7 lineto  790    0 lineto
     0    0 lineto
   935    0 moveto  970   21 lineto  986   22 lineto  989   30 lineto
   997   30 lineto 1006   35 lineto 1016   34 lineto 1023   38 lineto
  1040   51 lineto 1053   55 lineto 1057   51 lineto 1063   57 lineto
  1072   59 lineto 1077   66 lineto 1087   70 lineto 1089   70 lineto
  1097   63 lineto 1098   58 lineto 1104   57 lineto 1108   59 lineto
  1116   57 lineto 1129   56 lineto 1130   47 lineto 1141   38 lineto
  1158   41 lineto 1182   46 lineto 1202   45 lineto 1206   41 lineto
  1219   39 lineto 1226   41 lineto 1228   48 lineto 1246   49 lineto
  1249   52 lineto 1254   48 lineto 1255   39 lineto 1267   36 lineto
  1268   33 lineto 1278   27 lineto 1286   26 lineto 1287   10 lineto
  1293    9 lineto 1295    0 lineto
   935    0 lineto
  closepath
  1293 vedra_width div dup scale
  vedra_x1 -1 mul vedra_y1 -1 mul translate
} bind def

/slouchmanprofile {  % x y height direction slouchmanprofile   (sets path)
  10 dict begin
    [ /directn /height /y /x ] { exch def } forall
    x       y       translate height 106 div dup scale directn {-1 1 scale} if
    0 0 moveto 8 0 12 2 12 4 curveto 13 44 lineto 17 46 lineto 18 68 lineto
    18 80 12 88 7 93 curveto 3 97 1 106 -4 106 curveto % now at top of head
    -10 106 -14 103 -14 97 curveto -14 96 -14 90 -6 86 curveto
    -8 81 lineto  % now at shoulder
    -8 65 -4 60 -4 55 curveto -3 7 lineto -12 5 lineto
    -12 3 -10 2 -8 2 curveto  -8 0 -6 0 0 0 curveto
    closepath
    directn {-1 1 scale} if 106 height div dup scale 0 x sub 0 y sub translate
  end
} bind def

/connett {  % usage: x y width height dx [colours] xorigin yorigin grid connett
  % http://www.nahee.com/spanky/www/fractint/fractal_types.html  See circle:
  % Circle pattern by John Connett
  %    x + iy = pixel
  %    z = a*(x^2 + y^2)
  %    c = integer part of z
  %    color = c modulo(number of colors)
  % http://www.nahee.com/spanky/www/fractint/circle_type.html
  % This fractal type is from A. K. Dewdney's "Computer Recreations"
  % column in "Scientific American".
  % It is attributed to John Connett of the University of Minnesota.
  % dx is the size in points of the little coloured squares: e.g.: 2, 3, 4 or 5
  % [xy]origin to place the pattern's origin within rectangle x,y,width,heigth
  % grid = the spacing of the grid, in points
  % https://www.jstor.org/stable/2686389?
  % http://www.mpeters.de/mpeweb/hop/files/interfac.txt
  % http://xochipilli.com/content/circlesquared/
  % algorithm by John E. Connett originally published by A. K. Dewdney in his
  % "Computer Recreations" in the September 1986 issue of Scientific American.
  20 dict begin
  [/grid /yorigin /xorigin /colours /dx /height /width /y0 /x0]
    {exch def} forall
  /xmax x0 width  add def
  /ymax y0 height add def
  /ncolours colours rgblength def
  % I move to using grid-spacing instead of a as a parameter 
  /a ncolours 0.5 mul grid div def
  /i x0 def {
    /j y0 def {
      % z = a*(x^2 + y^2)     where   a = ncolours * dx * 0.5 / grid 
      /z  i xorigin sub dup mul  j yorigin sub  dup mul add  a mul def
      /c z dx div floor cvi ncolours mod def  % c = z mod ncolours
      colours c rgbget setrgbcolor
      i j dx dx rectfill
      j ymax gt { exit } if     % ymax
      /j j dx add def
    } loop
    i xmax gt { exit } if       % xmax
    /i i dx add def
  } loop
  end
} bind def

